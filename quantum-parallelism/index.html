<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Parallelism - In Depth</title>
    <link rel="stylesheet" href="../common/css/common.css">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <a href="../index.html" class="back-link">← Back to All Concepts</a>
        
        <header>
            <h1>Quantum Parallelism</h1>
            <p>Explore this quantum concept in depth</p>
        </header>

        <div class="content-grid">
            <!-- Input Section -->
            <section class="input-section">
                <h2>Input</h2>
                
                <div class="input-group">
                    <label for="num-qubits">
                        Number of Qubits
                        <span class="value-display" id="num-qubits-value">3</span>
                    </label>
                    <input type="range" id="num-qubits" min="1" max="5" step="1" value="3">
                </div>

                <div class="input-group">
                    <label for="function-type">Function to Evaluate</label>
                    <select id="function-type">
                        <option value="constant">Constant Function</option>
                        <option value="balanced" selected>Balanced Function</option>
                        <option value="identity">Identity Function</option>
                        <option value="custom">Custom Function</option>
                    </select>
                </div>

                <div class="input-group">
                    <label for="algorithm">Quantum Algorithm</label>
                    <select id="algorithm">
                        <option value="deutsch" selected>Deutsch's Algorithm</option>
                        <option value="deutsch-jozsa">Deutsch-Jozsa Algorithm</option>
                        <option value="bernstein-vazirani">Bernstein-Vazirani</option>
                        <option value="simon">Simon's Algorithm</option>
                    </select>
                </div>

                <div class="preset-buttons">
                    <button class="preset-btn" onclick="applyPreset('deutsch-demo')">Deutsch Demo</button>
                    <button class="preset-btn" onclick="applyPreset('exponential-speedup')">Exponential Speedup</button>
                    <button class="preset-btn" onclick="applyPreset('interference')">Interference Demo</button>
                </div>
            </section>

            <!-- Process Section -->
            <section class="process-section">
                <h2>Process</h2>
                
                <div class="process-step">
                    <h3>Step 1: The Power of Superposition</h3>
                    <p>
                        Quantum parallelism is the ability to evaluate a function f(x) on all possible inputs x simultaneously using superposition. For n qubits, there are 2ⁿ possible inputs. Classically, evaluating f on all inputs requires 2ⁿ function calls. Quantum mechanically, prepare the uniform superposition |ψ⟩ = (1/√2ⁿ)Σₓ|x⟩ (using n Hadamard gates on |0⟩ⁿ), then apply the quantum oracle Uₓ|x⟩|y⟩ = |x⟩|y⊕f(x)⟩. The result is (1/√2ⁿ)Σₓ|x⟩|f(x)⟩—a superposition containing f(x) for all x. This is quantum parallelism: one oracle call evaluates f on exponentially many inputs. However, there's a catch: measuring the state collapses it to a single |x⟩|f(x)⟩ pair, losing the parallelism. The key insight is to use interference to extract global properties of f (e.g., "is f constant or balanced?") without measuring individual f(x) values. Deutsch's algorithm (1985) was the first to exploit quantum parallelism for speedup, determining if f:{0,1}→{0,1} is constant or balanced with one query (classical: 2 queries required).
                    </p>
                    <div class="formula-box">
                        Superposition: H⊗ⁿ|0⟩ⁿ = (1/√2ⁿ)Σₓ|x⟩ (all 2ⁿ inputs)<br>
                        Oracle: Uₓ|x⟩|y⟩ = |x⟩|y⊕f(x)⟩<br>
                        Parallelism: One oracle call → f(x) for all x in superposition<br>
                        Deutsch: Constant vs balanced with 1 query (classical: 2)
                    </div>
                </div>

                <div class="process-step">
                    <h3>Step 2: Deutsch-Jozsa and Bernstein-Vazirani Algorithms</h3>
                    <p>
                        The Deutsch-Jozsa algorithm generalizes Deutsch's algorithm to n-bit functions. Given f:{0,1}ⁿ→{0,1} promised to be either constant (f(x)=0 for all x or f(x)=1 for all x) or balanced (f(x)=0 for exactly half the inputs), determine which. Classically, worst-case requires 2ⁿ⁻¹+1 queries. Quantum: prepare |+⟩⊗ⁿ|-⟩, apply Uₓ, then H⊗ⁿ. Measuring gives |0⟩ⁿ if constant, nonzero if balanced—one query! The algorithm uses interference: constant functions produce constructive interference at |0⟩ⁿ, balanced functions produce destructive interference. The Bernstein-Vazirani algorithm finds a hidden string s for f(x) = s·x (mod 2). Classically: n queries needed. Quantum: one query using the same circuit as Deutsch-Jozsa, measuring directly gives s. Both algorithms demonstrate exponential speedup (1 vs 2ⁿ queries) but solve promise problems with limited practical use. They prove quantum computers can outperform classical, inspiring Shor's and Grover's algorithms.
                    </p>
                    <div class="formula-box">
                        Deutsch-Jozsa: Constant vs balanced, 1 query (classical: 2ⁿ⁻¹+1)<br>
                        Circuit: H⊗ⁿ → Uₓ → H⊗ⁿ → Measure<br>
                        Bernstein-Vazirani: Find hidden s, 1 query (classical: n)<br>
                        Speedup: Exponential (1 vs 2ⁿ) for promise problems
                    </div>
                </div>

                <div class="process-step">
                    <h3>Step 3: Limitations and the Measurement Problem</h3>
                    <p>
                        Quantum parallelism alone does not solve NP-complete problems or enable "trying all solutions at once." The fundamental limitation: measurement collapses superposition, extracting only one outcome. If you evaluate f on all 2ⁿ inputs in superposition and measure, you get a random f(x)—no better than classical. The power comes from interference: carefully designed algorithms use quantum gates to amplify correct answers and cancel wrong ones before measurement. Grover's algorithm searches an unsorted database of N items in O(√N) steps (classical: O(N)), using amplitude amplification. Shor's algorithm factors integers in polynomial time (classical: exponential), using quantum Fourier transform to find period. Both exploit parallelism + interference. However, many problems (e.g., NP-complete) seem resistant to quantum speedup—no known quantum algorithm solves SAT or TSP exponentially faster. Quantum parallelism is not magic: it's constrained by unitarity, measurement, and the need for constructive interference. The "quantum speedup" comes from clever algorithm design, not raw parallelism.
                    </p>
                    <div class="formula-box">
                        Measurement problem: Superposition → one random outcome<br>
                        Grover: O(√N) search (classical: O(N))<br>
                        Shor: Polynomial factoring (classical: exponential)<br>
                        NP-complete: No known exponential quantum speedup
                    </div>
                </div>

                <div class="process-step">
                    <h3>Step 4: Practical Implications and Quantum Advantage</h3>
                    <p>
                        Quantum parallelism is central to quantum advantage: solving problems faster than any classical computer. Google's 2019 quantum supremacy experiment used a 53-qubit processor to sample from a distribution that would take classical supercomputers 10,000 years (disputed: IBM claimed 2.5 days with optimized classical algorithm). The task exploited parallelism to explore 2⁵³ ≈ 10¹⁶ states. Practical applications of quantum parallelism include quantum simulation (simulating quantum systems like molecules, materials), quantum machine learning (evaluating many hypotheses in superposition), and optimization (exploring solution spaces). However, decoherence limits parallelism: qubits lose coherence in microseconds to milliseconds, restricting circuit depth. Error correction (requiring 10³-10⁴ physical qubits per logical qubit) is needed for large-scale parallelism. Current NISQ (noisy intermediate-scale quantum) devices have 50-1000 qubits but limited coherence, enabling only shallow circuits. Future fault-tolerant quantum computers with 10⁶-10⁹ qubits will fully exploit parallelism for Shor's algorithm (breaking RSA), quantum chemistry (drug discovery), and optimization (logistics, finance). Quantum parallelism is a resource, like entanglement, enabling computational tasks impossible classically.
                    </p>
                    <div class="formula-box">
                        Quantum supremacy: 2⁵³ states explored (Google 2019)<br>
                        Applications: Simulation, ML, optimization<br>
                        NISQ devices: 50-1000 qubits, limited coherence<br>
                        Future: 10⁶-10⁹ qubits for Shor, chemistry, optimization
                    </div>
                </div>
            </section>

            <!-- Output Section -->
            <section class="output-section">
                <h2>Output</h2>
                
                <div class="visualization-container">
                    <h3>Visualization</h3>
                    <div id="visualization"></div>
                </div>

                <div class="output-info">
                    <h3>Results</h3>
                    <div id="results">
                        <p>Adjust the input parameters to see the results.</p>
                    </div>
                </div>
            </section>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="../common/js/blochSphere.js"></script>
    <script src="../common/js/ui.js"></script>
    <script src="script.js"></script>
</body>
</html>
